<!DOCTYPE html>
<html lang="en">
	<head>
		<title>PNG pottery</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> The Jars of Papua
		</div>

		<!-- Import maps polyfill -->
		<!-- Remove this when import maps will be widely supported -->
		<script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.module.js"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three';
			import { OrbitControls } from './jsm/controls/OrbitControls.js';
			import { VRButton } from './jsm/webxr/VRButton.js';
			import { XRControllerModelFactory } from './jsm/webxr/XRControllerModelFactory.js';
			import { GLTFLoader } from './jsm/loaders/GLTFLoader.js';
			import { DRACOLoader } from './jsm/loaders/DRACOLoader.js';
			
			let container;
			let camera, scene, renderer;
			let controller1, controller2;
			let controllerGrip1, controllerGrip2;
	
			let raycaster;

			const intersected = [];
			const intersected2 = [];
			const tempMatrix = new THREE.Matrix4();

			let controls, jars, torus;
// can either have 26 galleries that hide and show, or change the texture on one gallery. As changed out of init must be declared here.
			let gallery, adzeraG, agarabiG, aibomG, aloaloG, bauG, begilamG, collG, demtaG, dimiriG, huonG, ilesalesG;
			let kaiepG, kombioG, louisadeG, mailuG, malukuG, manusG, marikG, menoG, motoG, pubineriG, triobriandG, tumleoG;
			let waiGeoG, yabobG;

			init();
			animate();

			function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				scene = new THREE.Scene();
				//scene.background = new THREE.Color( 0x87ceeb ); // light blue
				scene.background = new THREE.Color( 0xf7d382 ); // peach
				
				camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.1, 10 );
				camera.position.set( 0, 1.6, 3 );

				controls = new OrbitControls( camera, container );
				controls.target.set( 0, 1.6, 0 );
				controls.update();

				const textureLoader = new THREE.TextureLoader()
				// Load information panels  -first one is instructions
				const introTexture = textureLoader.load( 'textures/Intro.jpg' );			
				const keyTexture = textureLoader.load( 'textures/key.jpg' );
				const adzeraTexture = textureLoader.load( 'textures/Adzera.jpg' );


				const gallery2 = new THREE.Mesh(new THREE.PlaneGeometry( 0.5, 0.5 ), new THREE.MeshBasicMaterial({ map: keyTexture }));
				gallery2.position.set( 0.75, 1.1, -.75); 
				scene.add( gallery2);


				gallery = new THREE.Mesh( new THREE.PlaneGeometry( 0.5, 0.5 ), new THREE.MeshBasicMaterial({ map: introTexture }));
				gallery.position.set( 0, 1.1, -.75); 
				scene.add( gallery);

				adzeraG = new THREE.Mesh( new THREE.PlaneGeometry( 0.5, 0.5 ), new THREE.MeshBasicMaterial({ map: adzeraTexture }));
				adzeraG.position.set( 0, 1.1, -.75); 
				scene.add( adzeraG);
				adzeraG.visible = false;

				//the Map
				const mapGeometry = new THREE.PlaneGeometry( 3.0, 1.5 );
				
				const mapTexture = textureLoader.load('textures/png.png'); //from google maps
				mapTexture.generateMipmaps = true //saves gpu if false
				const theMap = new THREE.Mesh( mapGeometry, new THREE.MeshBasicMaterial({ map: mapTexture }));
				theMap.rotation.x = - Math.PI / 2;
				theMap.position.set( 0, 0.73, 0); //desk
				scene.add( theMap);


				//Lights
				scene.add( new THREE.HemisphereLight( 0x808080, 0x606060 ) );
				const light = new THREE.DirectionalLight( 0xffffff );
				light.position.set( 0, 6, 0 );
				scene.add( light );


				// jars
				jars = new THREE.Group();
				scene.add( jars );
				const sectionMeshes = []
				let piecescale = 1;
				const loader = new GLTFLoader();
				const dracoLoader = new DRACOLoader();
 				dracoLoader.setDecoderPath( '/draco/' );
 				loader.setDRACOLoader( dracoLoader );

				const parameters = {
			    materialColor: '#9c5315',
				ringTopColor: '#19ffE7',
				coilColor: '#ff0000',
				paddleColor: '#1e2f97',
				coilBeatenColor: '#e8e337',
				paddleAddColor: '#a61ef4',
				wangelaColor: '#BEBEBE',
				amphColor: '#fc9483',
				nabColor: '#209F00'
				}

// really should change so scale or colour accepted as argument if pos
				function onLoad( gltf ) {
					const model = gltf.scene;					
					const x = Math.random() * 2 - 1;
					const y = 1.001;
					const z = Math.random() * 2 - 1;
					const piece = model.children[0];
					//piece.position.set( x, y, z );
					//piece.position.y = 1.5;
					piece.scale.set( piecescale, piecescale, piecescale);
					piece.material.color.set(parameters.materialColor);
					jars.add( piece);
					sectionMeshes.push(piece);
				}


				function onLoadCoil( gltf ) {
					const model = gltf.scene;					
					const x = Math.random() * 2 - 1;
					const y = 1.001;
					const z = Math.random() * 2 - 1;
					const piece = model.children[0];
					//piece.position.set( x, y, z );
					//piece.position.y = 1.5;
					piece.scale.set( piecescale, piecescale, piecescale);
					piece.material.color.set(parameters.coilColor);
					jars.add( piece);
					sectionMeshes.push(piece);
				}

				function onLoadCoilBeat( gltf ) {
					const model = gltf.scene;					
					const x = Math.random() * 2 - 1;
					const y = 1.001;
					const z = Math.random() * 2 - 1;
					const piece = model.children[0];
					//piece.position.set( x, y, z );
					//piece.position.y = 1.5;
					piece.scale.set( piecescale, piecescale, piecescale);
					piece.material.color.set(parameters.coilBeatenColor);
					jars.add( piece);
					sectionMeshes.push(piece);
				}
				function onLoadPaddle( gltf ) {
					const model = gltf.scene;					
					const x = Math.random() * 2 - 1;
					const y = 1.001;
					const z = Math.random() * 2 - 1;
					const piece = model.children[0];
					//piece.position.set( x, y, z );
					//piece.position.y = 1.5;
					piece.scale.set( piecescale, piecescale, piecescale);
					piece.material.color.set(parameters.paddleColor);
					jars.add( piece);
					sectionMeshes.push(piece);
				}
				function onLoadWangela( gltf ) {
					const model = gltf.scene;					
					const x = Math.random() * 2 - 1;
					const y = 1.001;
					const z = Math.random() * 2 - 1;
					const piece = model.children[0];
					//piece.position.set( x, y, z );
					//piece.position.y = 1.5;
					piece.scale.set( piecescale, piecescale, piecescale);
					piece.material.color.set(parameters.wangelaColor);
					jars.add( piece);
					sectionMeshes.push(piece);
				}
				function onLoadAmp( gltf ) {
					const model = gltf.scene;					
					const x = Math.random() * 2 - 1;
					const y = 1.001;
					const z = Math.random() * 2 - 1;
					const piece = model.children[0];
					//piece.position.set( x, y, z );
					//piece.position.y = 1.5;
					piece.scale.set( piecescale, piecescale, piecescale);
					piece.material.color.set(parameters.amphColor);
					jars.add( piece);
					sectionMeshes.push(piece);
				}

				function onLoadMailu( gltf ) {
					const model = gltf.scene;					
					const x = Math.random() * 2 - 1;
					const y = 1.001;
					const z = Math.random() * 2 - 1;
					const piece = model.children[0];
					//piece.position.set( x, y, z );
					//piece.position.y = 1.5;
					piece.scale.set( piecescale, piecescale, piecescale);
					piece.material.color.set(parameters.nabColor);
					jars.add( piece);
					sectionMeshes.push(piece);
				}

				function onLoadPaddleD( gltf ) {
					const model = gltf.scene;					
					const x = Math.random() * 2 - 1;
					const y = 1.001;
					const z = Math.random() * 2 - 1;
					const piece = model.children[0];
					//piece.position.set( x, y, z );
					//piece.position.y = 1.5;
					piece.scale.set( piecescale, piecescale, piecescale);
					piece.material.color.set(parameters.paddleAddColor);
					jars.add( piece);
					sectionMeshes.push(piece);
				}


				function onLoadRing( gltf ) {
					const model = gltf.scene;					
					const x = Math.random() * 2 - 1;
					const y = 1.001;
					const z = Math.random() * 2 - 1;
					const piece = model.children[0];
					//piece.position.set( x, y, z );
					//piece.position.y = 1.5;
					piece.scale.set( piecescale, piecescale, piecescale);
					piece.material.color.set(parameters.ringTopColor);
					jars.add( piece);
					sectionMeshes.push(piece);
				}

				loader.load( 'models/gltf/maluku.glb', onLoadPaddleD, undefined, function ( error ) {
					console.error( error );
				} );
				loader.load( 'models/gltf/adzera.glb', onLoadCoilBeat, undefined, function ( error ) {
					console.error( error );
				} );
				loader.load( 'models/gltf/agarabi.glb', onLoadCoilBeat, undefined, function ( error ) {
					console.error( error );
				} );
				loader.load( 'models/gltf/aibom.glb', onLoad, undefined, function ( error ) {
					console.error( error );
				} );
				loader.load( 'models/gltf/bau.glb', onLoadCoil, undefined, function ( error ) {
					console.error( error );
				} );
				loader.load( 'models/gltf/aloalo.glb', onLoadRing, undefined, function ( error ) {
					console.error( error );
				} );
				loader.load( 'models/gltf/begilam.glb', onLoadCoil, undefined, function ( error ) {
					console.error( error );
				} );
				loader.load( 'models/gltf/collingwood.glb', onLoadWangela, undefined, function ( error ) {
					console.error( error );
				} );
				loader.load( 'models/gltf/demta.glb', onLoad, undefined, function ( error ) {
					console.error( error );
				} );
				loader.load( 'models/gltf/dimiri.glb', onLoadCoil, undefined, function ( error ) {
					console.error( error );
				} );
				loader.load( 'models/gltf/huon.glb', onLoadPaddle, undefined, function ( error ) {
					console.error( error );
				} );
				loader.load( 'models/gltf/ilesales.glb', onLoadPaddle, undefined, function ( error ) {
					console.error( error );
				} );
				loader.load( 'models/gltf/kaiep.glb', onLoadPaddle, undefined, function ( error ) {
					console.error( error );
				} );
				loader.load( 'models/gltf/kombio.glb', onLoadCoil, undefined, function ( error ) {
					console.error( error );
				} );
				loader.load( 'models/gltf/louisade.glb', onLoadRing, undefined, function ( error ) {
					console.error( error );
				} );
				loader.load( 'models/gltf/mailu.glb', onLoadMailu, undefined, function ( error ) {
					console.error( error );
				} );
				loader.load( 'models/gltf/manus.glb', onLoadPaddle, undefined, function ( error ) {
					console.error( error );
				} );
				loader.load( 'models/gltf/marik.glb', onLoadCoil, undefined, function ( error ) {
					console.error( error );
				} );
				loader.load( 'models/gltf/meno.glb', onLoadCoil, undefined, function ( error ) {
					console.error( error );
				} );
				loader.load( 'models/gltf/moto.glb', onLoadPaddle, undefined, function ( error ) {
					console.error( error );
				} );
				loader.load( 'models/gltf/pubineri.glb', onLoadCoil, undefined, function ( error ) {
					console.error( error );
				} );
				loader.load( 'models/gltf/triobriand.glb', onLoadAmp, undefined, function ( error ) {
					console.error( error );
				} );
				loader.load( 'models/gltf/tumleo.glb', onLoadPaddle, undefined, function ( error ) {
					console.error( error );
				} );
				loader.load( 'models/gltf/waiGeo.glb', onLoadPaddleD, undefined, function ( error ) {
					console.error( error );
				} );
				loader.load( 'models/gltf/yabob.glb', onLoadPaddle, undefined, function ( error ) {
					console.error( error );
				} );

				// torus
				torus = new THREE.Group();
				scene.add( torus );
				const sectionTorus = []
				const torusMaterial = new THREE.MeshBasicMaterial({color: 0x006400});
				const torusGeometry = new THREE.TorusGeometry( 0.015, 0.005, 20, 20 );

				

				//addTorus(-0.86, -0.08); //Maluku
				//addTorus(-0.65, -0.35); // waiGeo
				//addTorus(0.13, -0.16); //Demta
				//addTorus(0.27, -0.12); // Tumleo
				//addTorus(0.33, -0.08); //Meno
				//addTorus(0.29, -0.05); // Kombio
				//addTorus(0.36, -0.01); //aibom
				//addTorus(0.41, -0.07); // kaiep
				//addTorus(0.66, -0.2); //Manus
				//addTorus(0.535, 0.04); // bau
				//addTorus(0.572, 0.0396); //yabob
				//addTorus(0.53, 0.09); // sumeo
				//addTorus(0.575, 0.079); ///marik
				//addTorus(0.71,0.13); // huon
				//addTorus(0.61, 0.15); //adzera
				//addTorus(1.01, 0.33); // triobriand
				//addTorus(0.85, 0.4); //collingwood
				//addTorus(0.71, 0.42); // moto
				//addTorus(0.84, 0.48); //mailu
				//addTorus(0.9, 0.49); // aloalo
				//addTorus(1.1,  0.55); //louisade
				//addTorus(-0.34, 0.11); // ilesales
				//addTorus(0.28, -0.01); //begilam
				//addTorus(0.43, 0); // dimiri
				//addTorus(0.55, 0.15); //agarabi

				const agarabiSite = new THREE.Mesh( new THREE.TorusGeometry( 0.015, 0.005, 20, 20 ), new THREE.MeshStandardMaterial({color: 0x006400}));
				agarabiSite.position.set(0.55, 0.74, 0.15);
				agarabiSite.scale.set( piecescale, piecescale, piecescale);
				agarabiSite.rotation.x = -Math.PI * 1/2;
				//agarabiSite.userData.planes = agarabiG;
				torus.add( agarabiSite);

				const dimiriSite = new THREE.Mesh( new THREE.TorusGeometry( 0.015, 0.005, 20, 20 ), new THREE.MeshStandardMaterial({color: 0x006400}));
				dimiriSite.position.set(0.43, 0.74, 0);
				dimiriSite.scale.set( piecescale, piecescale, piecescale);
				dimiriSite.rotation.x = -Math.PI * 1/2;
				//dimiriSite.userData.planes = dimiriG;
				torus.add(dimiriSite);

				const begilamSite = new THREE.Mesh( new THREE.TorusGeometry( 0.015, 0.005, 20, 20 ), new THREE.MeshStandardMaterial({color: 0x006400}));
				begilamSite.position.set(0.28, 0.74, -0.01);
				begilamSite.scale.set( piecescale, piecescale, piecescale);
				begilamSite.rotation.x = -Math.PI * 1/2;
				//begilamSite.userData.planes = begilamG;
				torus.add(begilamSite);

				const ilesalesSite = new THREE.Mesh( new THREE.TorusGeometry( 0.015, 0.005, 20, 20 ), new THREE.MeshStandardMaterial({color: 0x006400}));
				ilesalesSite.position.set(-0.34, 0.74, 0.11);
				ilesalesSite.scale.set( piecescale, piecescale, piecescale);
				ilesalesSite.rotation.x = -Math.PI * 1/2;
				// ilesalesSite.userData.planes = ilesalesG;
				torus.add( ilesalesSite);
		
				const louisadeSite = new THREE.Mesh( new THREE.TorusGeometry( 0.015, 0.005, 20, 20 ), new THREE.MeshStandardMaterial({color: 0x006400}));
				louisadeSite.position.set(1.1, 0.74, 0.55);
				louisadeSite.scale.set( piecescale, piecescale, piecescale);
				louisadeSite.rotation.x = -Math.PI * 1/2;
				// louisadeSite.userData.planes = louisadeG;
				torus.add(louisadeSite);

				const aloaloSite = new THREE.Mesh( new THREE.TorusGeometry( 0.015, 0.005, 20, 20 ), new THREE.MeshStandardMaterial({color: 0x006400}));
				aloaloSite.position.set(0.9, 0.74, 0.49);
				aloaloSite.scale.set( piecescale, piecescale, piecescale);
				aloaloSite.rotation.x = -Math.PI * 1/2;
				//aloaloSite.userData.planes = aloaloG;
				torus.add(aloaloSite);

				const mailuSite = new THREE.Mesh( new THREE.TorusGeometry( 0.015, 0.005, 20, 20 ), new THREE.MeshStandardMaterial({color: 0x006400}));
				mailuSite.position.set(0.84, 0.74, 0.48);
				mailuSite.scale.set( piecescale, piecescale, piecescale);
				mailuSite.rotation.x = -Math.PI * 1/2;
				//mailuSite.userData.planes = mailuG;
				torus.add(mailuSite);

				const motoSite = new THREE.Mesh( new THREE.TorusGeometry( 0.015, 0.005, 20, 20 ), new THREE.MeshStandardMaterial({color: 0x006400}));
				motoSite.position.set(0.71, 0.74, 0.42);
				motoSite.scale.set( piecescale, piecescale, piecescale);
				motoSite.rotation.x = -Math.PI * 1/2;
				// motoSite.userData.planes = motoG;
				torus.add( motoSite);

				const collSite = new THREE.Mesh( new THREE.TorusGeometry( 0.015, 0.005, 20, 20 ), new THREE.MeshStandardMaterial({color: 0x006400}));
				collSite.position.set(0.85, 0.74, 0.4);
				collSite.scale.set( piecescale, piecescale, piecescale);
				collSite.rotation.x = -Math.PI * 1/2;
				// collSite.userData.planes = collG;
				torus.add(collSite);

				const triobriandSite = new THREE.Mesh( new THREE.TorusGeometry( 0.015, 0.005, 20, 20 ), new THREE.MeshStandardMaterial({color: 0x006400}));
				triobriandSite.position.set(1.01, 0.74, 0.33);
				triobriandSite.scale.set( piecescale, piecescale, piecescale);
				triobriandSite.rotation.x = -Math.PI * 1/2;
				//triobriandSite.userData.planes = triobriandG;
				torus.add(triobriandSite);

				const adzeraSite = new THREE.Mesh( new THREE.TorusGeometry( 0.015, 0.005, 20, 20 ), new THREE.MeshStandardMaterial({color: 0x006400}));
				adzeraSite.position.set(0.61, 0.74, 0.15);
				adzeraSite.scale.set( piecescale, piecescale, piecescale);
				adzeraSite.rotation.x = -Math.PI * 1/2;
				//adzeraSite.userData.planes = adzeraG;
				torus.add(adzeraSite);

				const huonSite = new THREE.Mesh( new THREE.TorusGeometry( 0.015, 0.005, 20, 20 ), new THREE.MeshStandardMaterial({color: 0x006400}));
				huonSite.position.set(0.71, 0.74, 0.13);
				huonSite.scale.set( piecescale, piecescale, piecescale);
				huonSite.rotation.x = -Math.PI * 1/2;
				// huonSite.userData.planes = huonG;
				torus.add( huonSite);

				const marikSite = new THREE.Mesh( new THREE.TorusGeometry( 0.015, 0.005, 20, 20 ), new THREE.MeshStandardMaterial({color: 0x006400}));
				marikSite.position.set(0.575, 0.74, 0.079);
				marikSite.scale.set( piecescale, piecescale, piecescale);
				marikSite.rotation.x = -Math.PI * 1/2;
				// marikSite.userData.planes = marikG;
				torus.add(marikSite);

				const sumeoSite = new THREE.Mesh( new THREE.TorusGeometry( 0.015, 0.005, 20, 20 ), new THREE.MeshStandardMaterial({color: 0x006400}));
				sumeoSite.position.set(0.53, 0.74, 0.09);
				sumeoSite.scale.set( piecescale, piecescale, piecescale);
				sumeoSite.rotation.x = -Math.PI * 1/2;
				//sumeoSite.userData.planes = pubineriG;
				torus.add(sumeoSite);

				const yabobSite = new THREE.Mesh( new THREE.TorusGeometry( 0.015, 0.005, 20, 20 ), new THREE.MeshStandardMaterial({color: 0x006400}));
				yabobSite.position.set(0.572, 0.74, 0.0396);
				yabobSite.scale.set( piecescale, piecescale, piecescale);
				yabobSite.rotation.x = -Math.PI * 1/2;
				//yabobSite.userData.planes = yabobG;
				torus.add(yabobSite);

				const bauSite = new THREE.Mesh( new THREE.TorusGeometry( 0.015, 0.005, 20, 20 ), new THREE.MeshStandardMaterial({color: 0x006400}));
				bauSite.position.set(0.535, 0.74, 0.04);
				bauSite.scale.set( piecescale, piecescale, piecescale);
				bauSite.rotation.x = -Math.PI * 1/2;
				// bauSite.userData.planes = bauG;
				torus.add( bauSite);

				const manusSite = new THREE.Mesh( new THREE.TorusGeometry( 0.015, 0.005, 20, 20 ), new THREE.MeshStandardMaterial({color: 0x006400}));
				manusSite.position.set(0.66, 0.74, -0.2);
				manusSite.scale.set( piecescale, piecescale, piecescale);
				manusSite.rotation.x = -Math.PI * 1/2;
				// manusSite.userData.planes = manusG;
				torus.add(manusSite);
				
				const kaiepSite = new THREE.Mesh( new THREE.TorusGeometry( 0.015, 0.005, 20, 20 ), new THREE.MeshStandardMaterial({color: 0x006400}));
				kaiepSite.position.set(0.41, 0.74, -0.07);
				kaiepSite.scale.set( piecescale, piecescale, piecescale);
				kaiepSite.rotation.x = -Math.PI * 1/2;
				//kaiepSite.userData.planes = kaiepG;
				torus.add(kaiepSite);

				const aibomSite = new THREE.Mesh( new THREE.TorusGeometry( 0.015, 0.005, 20, 20 ), new THREE.MeshStandardMaterial({color: 0x006400}));
				aibomSite.position.set(0.36, 0.74,-0.01);
				aibomSite.scale.set( piecescale, piecescale, piecescale);
				aibomSite.rotation.x = -Math.PI * 1/2;
				//aibomSite.userData.planes = aibomG;
				torus.add(aibomSite);

				const kombioSite = new THREE.Mesh( new THREE.TorusGeometry( 0.015, 0.005, 20, 20 ), new THREE.MeshStandardMaterial({color: 0x006400}));
				kombioSite.position.set(0.29, 0.74, -0.05);
				kombioSite.scale.set( piecescale, piecescale, piecescale);
				kombioSite.rotation.x = -Math.PI * 1/2;
				// kombioSite.userData.planes = kombioG;
				torus.add( kombioSite);

				const menoSite = new THREE.Mesh( new THREE.TorusGeometry( 0.015, 0.005, 20, 20 ), new THREE.MeshStandardMaterial({color: 0x006400}));
				menoSite.position.set(0.33, 0.74, -0.08);
				menoSite.scale.set( piecescale, piecescale, piecescale);
				menoSite.rotation.x = -Math.PI * 1/2;
				// menoSite.userData.planes = menoG;
				torus.add(menoSite);

				const tumleoSite = new THREE.Mesh( new THREE.TorusGeometry( 0.015, 0.005, 20, 20 ), new THREE.MeshStandardMaterial({color: 0x006400}));
				tumleoSite.position.set(0.27, 0.74, -0.12);
				tumleoSite.scale.set( piecescale, piecescale, piecescale);
				tumleoSite.rotation.x = -Math.PI * 1/2;
				//tumleoSite.userData.planes = tumleoG;
				torus.add(tumleoSite);

				const demtaSite = new THREE.Mesh( new THREE.TorusGeometry( 0.015, 0.005, 20, 20 ), new THREE.MeshStandardMaterial({color: 0x006400}));
				demtaSite.position.set(0.13, 0.74, -0.16);
				demtaSite.scale.set( piecescale, piecescale, piecescale);
				demtaSite.rotation.x = -Math.PI * 1/2;
				//demtaSite.userData.planes = demtaG;
				torus.add(demtaSite);

				const waigeoSite = new THREE.Mesh( new THREE.TorusGeometry( 0.015, 0.005, 20, 20 ), new THREE.MeshStandardMaterial({color: 0x006400}));
				waigeoSite.position.set(-0.65, 0.74, -0.35);
				waigeoSite.scale.set( piecescale, piecescale, piecescale);
				waigeoSite.rotation.x = -Math.PI * 1/2;
				// waigeoSite.userData.planes = waiGeoG;
				torus.add( waigeoSite);

				const malukuSite = new THREE.Mesh( new THREE.TorusGeometry( 0.015, 0.005, 20, 20 ), new THREE.MeshStandardMaterial({color: 0x006400}));
				malukuSite.position.set(-0.86, 0.74, -0.08);
				malukuSite.scale.set( piecescale, piecescale, piecescale);
				malukuSite.rotation.x = -Math.PI * 1/2;
				// menoSite.userData.planes = malukuG;
				torus.add(malukuSite);

				// function addTorus( xpos, zpos) {
				// 	let torusObject = new THREE.Mesh( torusGeometry, torusMaterial );				
				// 	torusObject.position.set( xpos, 0.74, zpos );	
				// 	torusObject.scale.set( piecescale, piecescale, piecescale);
				// 	torusObject.rotation.x = -Math.PI * 1/2;
				// 	torus.add( torusObject );
				// 	sectionTorus.push(torusObject);
				// }

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.outputEncoding = THREE.sRGBEncoding;
				renderer.shadowMap.enabled = true;
				renderer.xr.enabled = true;
				container.appendChild( renderer.domElement );

				document.body.appendChild( VRButton.createButton( renderer ) );

				// controllers

				controller1 = renderer.xr.getController( 0 );
				controller1.addEventListener( 'selectstart', onSelectStart );
				controller1.addEventListener( 'selectend', onSelectEnd );
				scene.add( controller1 );

				controller2 = renderer.xr.getController( 1 );
				controller2.addEventListener( 'selectstart', onSelectStart2 );
				controller2.addEventListener( 'selectend', onSelectEnd2 );
				scene.add( controller2 );

				const controllerModelFactory = new XRControllerModelFactory();

				controllerGrip1 = renderer.xr.getControllerGrip( 0 );
				controllerGrip1.add( controllerModelFactory.createControllerModel( controllerGrip1 ) );
				scene.add( controllerGrip1 );

				controllerGrip2 = renderer.xr.getControllerGrip( 1 );
				controllerGrip2.add( controllerModelFactory.createControllerModel( controllerGrip2 ) );
				scene.add( controllerGrip2 );

				//

				const geometry = new THREE.BufferGeometry().setFromPoints( [ new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 0, - 1 ) ] );

				const line = new THREE.Line( geometry );
				line.name = 'line';
				line.scale.z = 5;

				controller1.add( line.clone() );
				controller2.add( line.clone() );

				raycaster = new THREE.Raycaster();

				//

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function onSelectStart2( event ) {

				const controller = event.target;

				const intersections = getIntersections2( controller );

				if ( intersections.length > 0 ) {

					const intersection = intersections[ 0 ];

					const object = intersection.object;
					//object.material.emissive.b = 1;
					object.material.emissive.b = 0;
					controller.attach( object );

					controller.userData.selected = object;

				}

			}

			function onSelectEnd2( event ) {

				const controller = event.target;

				if ( controller.userData.selected !== undefined ) {

					const object = controller.userData.selected;
					object.material.emissive.b = 0;
					jars.attach( object );

					controller.userData.selected = undefined;

				}


			}
			function onSelectStart( event ) {

				const controller = event.target;

				const intersections = getIntersections( controller );

				if ( intersections.length > 0 ) {

					const intersection = intersections[ 0 ];

					const object = intersection.object;
					//object.material.emissive.b = 1;
					object.material.emissive.b = 0;
					controller.attach( object );

					controller.userData.selected = object;

				}

			}

			function onSelectEnd( event ) {

				const controller = event.target;

				if ( controller.userData.selected !== undefined ) {

					const object = controller.userData.selected;
					object.material.emissive.b = 0;
					jars.attach( object );

					controller.userData.selected = undefined;

				}


			}


			function getIntersections( controller ) {

				tempMatrix.identity().extractRotation( controller.matrixWorld );

				raycaster.ray.origin.setFromMatrixPosition( controller.matrixWorld );
				raycaster.ray.direction.set( 0, 0, - 1 ).applyMatrix4( tempMatrix );
//need to text if jar or torus- or select different
				return raycaster.intersectObjects( jars.children, false );

			}

			function getIntersections2( controller ) {

			tempMatrix.identity().extractRotation( controller.matrixWorld );

			raycaster.ray.origin.setFromMatrixPosition( controller.matrixWorld );
			raycaster.ray.direction.set( 0, 0, - 1 ).applyMatrix4( tempMatrix );
//need to text if jar or torus- or select different
			return raycaster.intersectObjects( jars.children, false );

			}			

			function intersectObjects( controller ) {

				// Do not highlight when already selected

				if ( controller.userData.selected !== undefined ) return;

				const line = controller.getObjectByName( 'line' );
				const intersections = getIntersections( controller );

				if ( intersections.length > 0 ) {

					const intersection = intersections[ 0 ];

					const object = intersection.object;
					object.material.emissive.r = 1;
					intersected.push( object );

					line.scale.z = intersection.distance;

				} else {

					line.scale.z = 5;

				}

			}

			function intersectObjects2( controller ) {

			// Do not highlight when already selected

			if ( controller.userData.selected !== undefined ) return;

				const line = controller.getObjectByName( 'line' );
				const intersections = getIntersections2( controller );

			if ( intersections.length > 0 ) {

				const intersection = intersections[ 0 ];

				const object = intersection.object;
				object.material.emissive.r = 1;
				intersected2.push( object );

				line.scale.z = intersection.distance;

			} else {

				line.scale.z = 5;

			}

		}

			function cleanIntersected() {

				while ( intersected.length ) {

					const object = intersected.pop();
					object.material.emissive.r = 0;

				}
			}
			function cleanIntersected2() {

				while ( intersected2.length ) {

					const object = intersected2.pop();
					object.material.emissive.r = 0;

				}
			}

			function animate() {

				renderer.setAnimationLoop( render );

			}

			function render() {

				cleanIntersected();
				cleanIntersected2();
				intersectObjects( controller1 );
				intersectObjects2( controller2 );

				renderer.render( scene, camera );

			}

		</script>
	</body>
</html>