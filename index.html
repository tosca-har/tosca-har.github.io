<!DOCTYPE html>
<html lang="en">
<head>
	<title>PNG pottery</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
	<link type="text/css" rel="stylesheet" href="main.css">
    <script type="importmap">
        {
            "imports": {
            	"three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
     </script>
</head>
<body>

	<div id="info">
		<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> The Jars of Papua
	</div>

	<script type="module">
		import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
		import { DragControls } from 'three/addons/controls/DragControls.js';
        import { VRButton } from 'three/addons/webxr/VRButton.js';
		import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';
			
        let container;
		let camera, scene, renderer, controls, dragControls, dragControlsM;
		let controller1, controller2, controllerGrip1, controllerGrip2;
		let raycasterM, pointer, selectedTorus; // for mouse controls
		let raycaster; // for VR controls
		const intersected = [];
		const intersected2 = [];
		const intersected3 = [];
		const tempMatrix = new THREE.Matrix4(); //for VR controllers
		let ratio = 2;
		let desk = 0.8; // desk height
		let gheight = desk + 0.55; //panel height
		let psize = 1.0; // panel dimensions
		let gallery, adzeraG, aibomG, mailuG, dimiriG, louisadeG, yabobG;
		let selectedPlane;	

		const loader = new GLTFLoader();
		const dracoLoader = new DRACOLoader();
		dracoLoader.setDecoderPath( 'https://unpkg.com/three@0.160.0/examples/jsm/libs/draco/' );
		loader.setDRACOLoader( dracoLoader );

		let mapGroup, jars, torus, torusA, trueposition, aworld;
		let adzeraM, aibomM, mailuM, louisadeM, dimiriM, yabobM;

		init(); 
		animate();

   		function init() {
			container = document.createElement( 'div' );
			document.body.appendChild( container );
			scene = new THREE.Scene();
			scene.background = new THREE.Color( 0xf7d382 );
					
			camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.1, 10 );
			camera.position.set( 0, 1.6, 3 );
			const textureLoader = new THREE.TextureLoader()

			const introTexture = textureLoader.load( 'textures/Intro.jpg' );
			const refTexture = textureLoader.load( 'textures/sources.jpg' );			
			const keyTexture = textureLoader.load( 'textures/key.jpg' );
			const adzeraTexture = textureLoader.load( 'textures/Adzera.jpg' );
			const aibomTexture = textureLoader.load( 'textures/Aibom.jpg' );
			const mailuTexture = textureLoader.load( 'textures/Mailu.jpg' );
			const dimiriTexture = textureLoader.load( 'textures/Dimiri.jpg' );
			const louisadeTexture = textureLoader.load( 'textures/Louisade.jpg' );
			const yabobTexture = textureLoader.load( 'textures/Yabob.jpg' );

			gallery = new THREE.Mesh( new THREE.PlaneGeometry( psize, psize  ), new THREE.MeshBasicMaterial({ map: introTexture }));
			gallery.position.set( 0, gheight, -.75); 
			selectedPlane = gallery;
			const gallery2 = new THREE.Mesh(new THREE.PlaneGeometry( psize, psize ), new THREE.MeshBasicMaterial({ map: keyTexture }));
			gallery2.position.set( 1.25, gheight, -.75); 
			const gallery3 = new THREE.Mesh(new THREE.PlaneGeometry(psize, psize  ), new THREE.MeshBasicMaterial({ map: refTexture }));
			gallery3.position.set( -1.25, gheight, -.75); 

			scene.add( gallery, gallery2, gallery3);

			adzeraG = new THREE.Mesh( new THREE.PlaneGeometry( psize, psize  ), new THREE.MeshBasicMaterial({ map: adzeraTexture }));
			adzeraG.position.set( 0, gheight, -.75); 
			scene.add( adzeraG);
			adzeraG.visible = false;

			aibomG = new THREE.Mesh( new THREE.PlaneGeometry( psize, psize  ), new THREE.MeshBasicMaterial({ map: aibomTexture }));
			aibomG.position.set( 0, gheight, -.75); 
			scene.add( aibomG);
			aibomG.visible = false;

			mailuG = new THREE.Mesh( new THREE.PlaneGeometry( psize, psize  ), new THREE.MeshBasicMaterial({ map: mailuTexture }));
			mailuG.position.set( 0, gheight, -.75); 
			scene.add( mailuG);
			mailuG.visible = false;

			dimiriG = new THREE.Mesh( new THREE.PlaneGeometry( psize, psize  ), new THREE.MeshBasicMaterial({ map: dimiriTexture }));
			dimiriG.position.set( 0, gheight, -.75); 
			scene.add(dimiriG);
			dimiriG.visible = false;

			louisadeG = new THREE.Mesh( new THREE.PlaneGeometry( psize, psize  ), new THREE.MeshBasicMaterial({ map: louisadeTexture }));
			louisadeG.position.set( 0, gheight, -.75); 
			scene.add( louisadeG);
			louisadeG.visible = false;

			yabobG = new THREE.Mesh( new THREE.PlaneGeometry( psize, psize ), new THREE.MeshBasicMaterial({ map: yabobTexture }));
			yabobG.position.set( 0, gheight, -.75); 
			scene.add(yabobG);
			yabobG.visible = false;

			//the Map
			const mapGeometry = new THREE.PlaneGeometry( 3.0 * ratio, 1.5 * ratio );
			const mapTexture = textureLoader.load('textures/png.png'); //from google maps
			mapTexture.generateMipmaps = true //saves gpu if false
			const theMap = new THREE.Mesh( mapGeometry, new THREE.MeshBasicMaterial({ map: mapTexture }));
			theMap.rotation.x = - Math.PI / 2;
			theMap.position.set( 0, desk, 0); //desk
			//scene.add( theMap);
        	scene.add( new THREE.HemisphereLight( 0xffffbb, 0x080820, .5) );
			const light = new THREE.DirectionalLight( 0xffffff );
			light.position.set( 1, 6, 2 );
			scene.add( light );
			const parameters = {
				materialColor: '#9c5315', 
				ringTopColor: '#19ffE7',
				coilColor: '#ff0000',
				paddleColor: '#1e2f97', 
				coilBeatenColor: '#e8e337',
				paddleAddColor: '#a61ef4',
				wangelaColor: '#BEBEBE', 
				amphColor: '#fc9483',
				nabColor: '#209F00' 
			}
    		//spheres for key
			const sphere = new THREE.SphereGeometry( 0.04, 15, 5); 

			const sphere1 = new THREE.Mesh( sphere,  new THREE.MeshStandardMaterial( {color: parameters.materialColor })); 
			sphere1.position.set( 0.84, gheight + (psize *.30), -.75); 

			const sphere2 = new THREE.Mesh( sphere,  new THREE.MeshStandardMaterial( {color: parameters.coilColor })); 
			sphere2.position.set( 0.84, gheight + (psize *.21), -.75); 

			const sphere3 = new THREE.Mesh( sphere,  new THREE.MeshStandardMaterial( {color: parameters.wangelaColor })); 
			sphere3.position.set( 0.84, gheight - (psize *.15), -.75); 

			const sphere4 = new THREE.Mesh( sphere,  new THREE.MeshStandardMaterial( {color: parameters.nabColor })); 
			sphere4.position.set( 0.84, gheight - (psize *.06), -.75); 

			const sphere5 = new THREE.Mesh( sphere,  new THREE.MeshStandardMaterial( {color: parameters.paddleAddColor})); 
			sphere5.position.set( 0.84, gheight - (psize *.35), -.75); 

			const sphere6 = new THREE.Mesh( sphere,  new THREE.MeshStandardMaterial( {color: parameters.coilBeatenColor})); 
			sphere6.position.set( 0.84, gheight + (psize *.03), -.75); 

			const sphere7 = new THREE.Mesh( sphere,  new THREE.MeshStandardMaterial( {color: parameters.amphColor })); 
			sphere7.position.set( 0.84, gheight - (psize *.44), -.75); 

			const sphere8 = new THREE.Mesh( sphere,  new THREE.MeshStandardMaterial( {color: parameters.paddleColor})); 
			sphere8.position.set( 0.84, gheight - (psize *.25), -.75); 

			const sphere9 = new THREE.Mesh( sphere,  new THREE.MeshStandardMaterial( {color: parameters.ringTopColor})); 
			sphere9.position.set( 0.84, gheight + (psize *.12), -.75); 
			
			scene.add( sphere1, sphere2, sphere3, sphere4, sphere5, sphere6, sphere7, sphere8, sphere9 );

			jars = new THREE.Group();
			scene.add( jars );
			aworld = new THREE.Group();
			scene.add(aworld); 
			let piecescale = ratio;
			torus = new THREE.Group();
			torusA = [];
			//scene.add(torus);
			mapGroup = new THREE.Group();
			mapGroup.attach(torus);
			mapGroup.add( theMap);
			aworld.add( mapGroup);

			
			const dimiriSite = new THREE.Mesh( new THREE.TorusGeometry(0.015, 0.007, 20, 20  ), new THREE.MeshStandardMaterial({color: 0x006400}));
			dimiriSite.position.set(0.43 *ratio, desk + 0.01, 0 *ratio);
			dimiriSite.scale.set( piecescale, piecescale, piecescale);
			dimiriSite.rotation.x = -Math.PI * 1/2;
			dimiriSite.userData.planes = dimiriG;
			torus.attach(dimiriSite);
			torusA.push(dimiriSite);

			const louisadeSite = new THREE.Mesh( new THREE.TorusGeometry( 0.015, 0.007, 20, 20 ), new THREE.MeshStandardMaterial({color: 0x006400}));
			louisadeSite.position.set(0.99* ratio, desk + 0.01, 0.59* ratio);
			louisadeSite.scale.set( piecescale, piecescale, piecescale);
			louisadeSite.rotation.x = -Math.PI * 1/2;
			louisadeSite.userData.planes = louisadeG;
			torus.attach(louisadeSite);
			torusA.push(louisadeSite);

			const mailuSite = new THREE.Mesh( new THREE.TorusGeometry( 0.015, 0.007, 20, 20 ), new THREE.MeshStandardMaterial({color: 0x006400}));
			mailuSite.position.set(0.84* ratio, desk + 0.01, 0.48* ratio);
			mailuSite.scale.set( piecescale, piecescale, piecescale);
			mailuSite.rotation.x = -Math.PI * 1/2;
			mailuSite.userData.planes = mailuG;
			torus.attach(mailuSite);
			torusA.push(mailuSite);
			
			const adzeraSite = new THREE.Mesh( new THREE.TorusGeometry( 0.015, 0.007, 20, 20 ), new THREE.MeshStandardMaterial({color: 0x006400}));
			adzeraSite.position.set(0.61* ratio, desk + 0.01, 0.15* ratio);
			adzeraSite.scale.set( piecescale, piecescale, piecescale);
			adzeraSite.rotation.x = -Math.PI * 1/2;
			adzeraSite.userData.planes = adzeraG;
			torus.attach(adzeraSite);
			torusA.push(adzeraSite);

			const yabobSite = new THREE.Mesh( new THREE.TorusGeometry( 0.015, 0.007, 20, 20 ), new THREE.MeshStandardMaterial({color: 0x006400}));
			yabobSite.position.set(0.572* ratio, desk + 0.01, 0.0396* ratio);
			yabobSite.scale.set( piecescale, piecescale, piecescale);
			yabobSite.rotation.x = -Math.PI * 1/2;
			yabobSite.userData.planes = yabobG;
			torus.attach(yabobSite);
			torusA.push(yabobSite);
				
			const aibomSite = new THREE.Mesh( new THREE.TorusGeometry( 0.015, 0.007, 20, 20 ), new THREE.MeshStandardMaterial({color: 0x006400}));
			aibomSite.position.set(0.36* ratio, desk + 0.01,-0.01* ratio);
			aibomSite.scale.set( piecescale, piecescale, piecescale);
			aibomSite.rotation.x = -Math.PI * 1/2;
			aibomSite.userData.planes = aibomG;
			torus.attach(aibomSite);
			torusA.push(aibomSite);

			selectedTorus = aibomSite; 

			function onLoadAdzera( gltf ) {
				const model = gltf.scene;					
				adzeraM = model.children[0];
				adzeraM.material = new THREE.MeshStandardMaterial();
				adzeraM.position.set( Math.random() - 1, 1.2, Math.random() * 0.5 - 0.3 );
				adzeraM.scale.set( piecescale, piecescale, piecescale);
				adzeraM.material.color.set(parameters.coilBeatenColor);
				adzeraM.userData.loc = new THREE.Vector3(0.61 * ratio, desk + 0.01, 0.15 * ratio);
				adzeraM.userData.site = adzeraSite;
				adzeraM.userData.type = 1;
				jars.add( adzeraM);
			}
			loader.load( 'models/gltf/adzera.glb', onLoadAdzera, undefined, function ( error ) { console.error( error );} );
							
			function onLoadAibom( gltf ) {
				const model = gltf.scene;					
				aibomM = model.children[0];
				aibomM.material = new THREE.MeshStandardMaterial();
				aibomM.position.set( Math.random() - 1, 1.2, Math.random() * 0.5 - 0.3 );
				aibomM.scale.set( piecescale, piecescale, piecescale);
				aibomM.material.color.set(parameters.materialColor);
				aibomM.userData.loc = new THREE.Vector3(0.36* ratio, desk + 0.01,-0.01* ratio);
				aibomM.userData.site = aibomSite;
				jars.add( aibomM);
			}
			loader.load( 'models/gltf/aibom.glb', onLoadAibom, undefined, function ( error ) {console.error( error );} );	

			function onLoadMailu( gltf ) {
				const model = gltf.scene;					
				mailuM = model.children[0];
				mailuM.material = new THREE.MeshStandardMaterial();
				mailuM.position.set(Math.random() - 1, 1.2, Math.random() * 0.5 - 0.3 );
				mailuM.scale.set( piecescale, piecescale, piecescale);
				mailuM.material.color.set(parameters.nabColor);
				mailuM.userData.loc = new THREE.Vector3(0.84* ratio, desk + 0.01, 0.48* ratio);
				mailuM.userData.site = mailuSite;
				jars.add( mailuM);
			}
			loader.load( 'models/gltf/mailu.glb', onLoadMailu, undefined, function ( error ) { console.error( error );} );

			function onLoadLouisade( gltf ) {
				const model = gltf.scene;					
				louisadeM = model.children[0];
				louisadeM.material = new THREE.MeshStandardMaterial();
				louisadeM.position.set( Math.random() - 1, 1.2, Math.random() * 0.5 - 0.3  );
				louisadeM.scale.set( piecescale, piecescale, piecescale);
				louisadeM.material.color.set(parameters.ringTopColor);
				louisadeM.userData.loc = new THREE.Vector3(0.99* ratio, desk + 0.01, 0.59* ratio);
				louisadeM.userData.site = louisadeSite;
				jars.add( louisadeM);
			}
			loader.load( 'models/gltf/louisade.glb', onLoadLouisade, undefined, function ( error ) {console.error( error );} );

			function onLoadDimiri( gltf ) {
				const model = gltf.scene;					
				dimiriM = model.children[0];
				dimiriM.material = new THREE.MeshStandardMaterial();
				dimiriM.position.set( Math.random() - 1, 1.2, Math.random() * 0.5 - 0.3 );
				dimiriM.scale.set( piecescale, piecescale, piecescale);
				dimiriM.material.color.set(parameters.coilColor);
				dimiriM.userData.loc = new THREE.Vector3(0.43* ratio, desk + 0.01, 0* ratio);
				dimiriM.userData.site = dimiriSite;
				jars.add( dimiriM);
			}
			loader.load( 'models/gltf/dimiri.glb', onLoadDimiri, undefined, function ( error ) { console.error( error );} );

			function onLoadYabob( gltf ) {
				const model = gltf.scene;					
				yabobM = model.children[0];
				yabobM.material = new THREE.MeshStandardMaterial();
				yabobM.position.set( Math.random() - 1, 1.2, Math.random() * 0.5 - 0.3 );
				yabobM.scale.set( piecescale, piecescale, piecescale);
				yabobM.material.color.set(parameters.paddleColor);
				yabobM.userData.loc = new THREE.Vector3(0.572* ratio, desk + 0.01, 0.0396* ratio);
				yabobM.userData.site = yabobSite;
				jars.add( yabobM);
				}
			loader.load( 'models/gltf/yabob.glb', onLoadYabob, undefined, function ( error ) {console.error( error );} );
			
			renderer = new THREE.WebGLRenderer( { antialias: true } );
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.setSize( window.innerWidth, window.innerHeight );
			renderer.xr.enabled = true;
			container.appendChild( renderer.domElement );
			document.body.appendChild( VRButton.createButton( renderer ) );
			controls = new OrbitControls( camera, renderer.domElement);
			controls.target.set( 0, 1.6, 0 );
			controls.update();

			dragControls = new DragControls( [ jars ], camera, renderer.domElement );
    		dragControls.addEventListener('dragstart', function (event) {
        	controls.enabled = false;
			dragControlsM.enabled = false;
    		})

			dragControls.addEventListener('dragend', function (event) {
				controls.enabled = true
				dragControlsM.enabled = true;
				let object = event.object;
				let aposition = object.position; 

				trueposition = object.userData.site;
				
				let testposition = new THREE.Vector3(0,0,0); //needs to be something first
				trueposition.getWorldPosition( testposition ); //a Vector3 (x,y,z)

				if ( aposition.distanceTo( testposition ) < .025 * ratio) {
					scene.background = new THREE.Color( Math.random() * 0xffffff ); // random
					object.position.set(testposition.x, testposition.y, testposition.z);
					object.rotation.set(0, 0, 0);
					mapGroup.attach( object );
				}		
    		})


			dragControlsM = new DragControls(  [ mapGroup ] , camera, renderer.domElement );
			dragControlsM.transformGroup = true;
		
    		dragControlsM.addEventListener('dragstart', function (event) {
        	controls.enabled = false
    		})

			dragControlsM.addEventListener('dragend', function (event) {
				controls.enabled = true	
    		})
 

			controller1 = renderer.xr.getController( 0 );
			controller1.addEventListener( 'selectstart', onSelectStart );
			controller1.addEventListener( 'selectend', onSelectEnd );
			scene.add( controller1 );

			controller2 = renderer.xr.getController( 1 );
			controller2.addEventListener( 'selectstart', onSelectStart2 );
			//controller2.addEventListener( 'selectend', onSelectEnd2 );
			controller2.addEventListener( 'selectend', onSelectEnd3 );
			scene.add( controller2 );
			const controllerModelFactory = new XRControllerModelFactory();

			controllerGrip1 = renderer.xr.getControllerGrip( 0 );
			controllerGrip1.add( controllerModelFactory.createControllerModel( controllerGrip1 ) );
			scene.add( controllerGrip1 );

			controllerGrip2 = renderer.xr.getControllerGrip( 1 );
			controllerGrip2.add( controllerModelFactory.createControllerModel( controllerGrip2 ) );
			scene.add( controllerGrip2 );
			const geometry = new THREE.BufferGeometry().setFromPoints( [ new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 0, - 1 ) ] );
			const line = new THREE.Line( geometry );
			line.name = 'line';
			line.scale.z = 5;

			controller1.add( line.clone() );
			controller2.add( line.clone() );

			raycaster = new THREE.Raycaster(); //for VR

			raycasterM = new THREE.Raycaster(); 
			pointer = new THREE.Vector2(); 
			selectedTorus = new THREE.Mesh( new THREE.TorusGeometry( 0.015, 0.007, 20, 20  ), new THREE.MeshStandardMaterial({color: 0x006400})); // initalise so not null (or test if null before emission change)

			window.addEventListener( 'click', onClick );
			window.addEventListener( 'resize', onWindowResize );
		}
		function onWindowResize() {
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();
			renderer.setSize( window.innerWidth, window.innerHeight );
		}


		function onSelectStart( event ) {
			const controller = event.target;
			const intersections = getIntersections( controller );
			if ( intersections.length > 0 ) {
				const intersection = intersections[ 0 ];
				const object = intersection.object;
				object.material.emissive.b = 0;				
				controller.userData.selected = object;
			}
		}

		function onSelectEnd( event ) {
			const controller = event.target;
			if ( controller.userData.selected !== undefined ) {
				const object = controller.userData.selected;
				object.material.emissive.b = 0;				
				selectedPlane.visible = false;
				selectedPlane = object.userData.planes;
				selectedPlane.visible = true;
				controller.userData.selected = undefined;
			}
		}

		function getIntersections( controller ) {
			tempMatrix.identity().extractRotation( controller.matrixWorld );
			raycaster.ray.origin.setFromMatrixPosition( controller.matrixWorld );
			raycaster.ray.direction.set( 0, 0, - 1 ).applyMatrix4( tempMatrix );
			return raycaster.intersectObjects( torus.children, false );
		}
	
		function intersectObjects( controller ) {
			// Do not highlight when already selected
			if ( controller.userData.selected !== undefined ) return;
			const line = controller.getObjectByName( 'line' );
			const intersections = getIntersections( controller );
			if ( intersections.length > 0 ) {
				const intersection = intersections[ 0 ];
				const object = intersection.object;
				object.material.emissive.r = 1;
				intersected.push( object );
				line.scale.z = intersection.distance;
			} else {
				line.scale.z = 5;
			}
		}

		function cleanIntersected() {
			while ( intersected.length ) {
				const object = intersected.pop();
				object.material.emissive.r = 0;
			}
		}
		function onSelectStart2( event ) {
			const controller = event.target;
			const intersections = getIntersections2( controller );
			if ( intersections.length > 0 ) {
				const intersection = intersections[ 0 ];
				const object = intersection.object;
				object.material.emissive.b = 0;
				controller.attach( object );
				controller.userData.selected = object;
			} else { 
				const intersections = getIntersections3( controller );
					if ( intersections.length > 0 ) {
					//const intersection = intersections[ 0 ];
					//const object = intersection.object;
					controller.attach( mapGroup );
					controller.userData.selected = mapGroup;
					}
			}
		}

		function onSelectEnd2( event ) {
			const controller = event.target;
			if ( controller.userData.selected !== undefined ) {
				//if (controller.userData.selected !== mapGroup ){
				const object = controller.userData.selected;
				object.material.emissive.b = 0;				
				//test if position is right
				let aposition = new THREE.Vector3(0,0,0); //needs to be something first
				object.getWorldPosition( aposition ); //a Vector3 (x,y,z)
				//trueposition = object.userData.loc;
				trueposition = object.userData.site;			
				let testposition = new THREE.Vector3(0,0,0); //needs to be something first
				trueposition.getWorldPosition( testposition ); //a Vector3 (x,y,z)

				jars.attach( object );
				if ( aposition.distanceTo( testposition ) < .025 * ratio) {
					scene.background = new THREE.Color( Math.random() * 0xffffff ); // random
					object.position.set(testposition.x, testposition.y, testposition.z);
					object.rotation.set(0, 0, 0); //or get the rotation of the mapGroup or site and set it to that?
					mapGroup.attach( object );
				}									
				controller.userData.selected = undefined;
				//}
			}
		}

		function onSelectEnd3( event ) {
			const controller = event.target;
			if ( controller.userData.selected !== undefined ) {	
				if (controller.userData.selected == mapGroup ){						
					aworld.attach(mapGroup);								
				} else {
					const object = controller.userData.selected;
					object.material.emissive.b = 0;				
					//test if position is right
					let aposition = new THREE.Vector3(0,0,0); //needs to be something first
					object.getWorldPosition( aposition ); //a Vector3 (x,y,z)
					trueposition = object.userData.site;			
					let testposition = new THREE.Vector3(0,0,0); //needs to be something first
					trueposition.getWorldPosition( testposition ); //a Vector3 (x,y,z)
					jars.attach( object );
					if ( aposition.distanceTo( testposition ) < .025 * ratio) {
						scene.background = new THREE.Color( Math.random() * 0xffffff ); // random
						object.position.set(testposition.x, testposition.y, testposition.z);
						//let maprotation = new THREE.Vector3(0,0,0);
						let maprotation = new THREE.Quaternion(0,0,0,0)
						mapGroup.getWorldQuaternion(maprotation); //quaternion
						object.setRotationFromQuaternion(maprotation)
						//mapGroup.getWorldDirection(maprotation);
						//object.rotation.set(maprotation.x, maprotation.y, maprotation.z); //or get the rotation of the mapGroup or site and set it to that?
						mapGroup.attach( object );
					}									
				
				}
				controller.userData.selected = undefined;
			}
		}

			function getIntersections2( controller ) {
				tempMatrix.identity().extractRotation( controller.matrixWorld );
				raycaster.ray.origin.setFromMatrixPosition( controller.matrixWorld );
				raycaster.ray.direction.set( 0, 0, - 1 ).applyMatrix4( tempMatrix );
				return raycaster.intersectObjects( jars.children, false );
			}
			function getIntersections3( controller ) {
				tempMatrix.identity().extractRotation( controller.matrixWorld );
				raycaster.ray.origin.setFromMatrixPosition( controller.matrixWorld );
				raycaster.ray.direction.set( 0, 0, - 1 ).applyMatrix4( tempMatrix );
				return raycaster.intersectObjects( mapGroup.children, false );
			}
			function intersectObjects2( controller ) {
			// Do not highlight when already selected
			if ( controller.userData.selected !== undefined ) return;

				const line = controller.getObjectByName( 'line' );
				const intersections = getIntersections2( controller );

			if ( intersections.length > 0 ) {
				const intersection = intersections[ 0 ];
				const object = intersection.object;
				object.material.emissive.r = 1;
				intersected2.push( object );
				line.scale.z = intersection.distance;

			} else {
				line.scale.z = 5;
			}
		}
		function cleanIntersected2() {
				while ( intersected2.length ) {
					const object = intersected2.pop();
					object.material.emissive.r = 0;
				}
			}
    	function onClick( event ) {
			event.preventDefault();
			pointer.x = event.clientX / window.innerWidth * 2 - 1
			pointer.y = - (event.clientY / window.innerHeight) * 2 + 1
			raycasterM.setFromCamera( pointer, camera );
			const intersects = raycasterM.intersectObjects( torus.children);
					
			if(intersects.length > 0){
				selectedTorus.material.emissive.r = 0;
				const found = intersects[ 0 ].object;
				selectedTorus = found;
				found.material.emissive.r = 1;
				selectedPlane.visible = false;
				selectedPlane = found.userData.planes;
				selectedPlane.visible = true;
			}
		}

		function animate() {
			renderer.setAnimationLoop( render );
		}

		function render() {
				cleanIntersected();
				cleanIntersected2();
				intersectObjects( controller1 );
				intersectObjects2( controller2);
				renderer.render( scene, camera );
			}
    </script>
</body>
</html>